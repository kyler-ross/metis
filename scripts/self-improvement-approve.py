#!/usr/bin/env python3
"""
Self-Improvement Approval & Auto-Commit System

Processes pending improvement proposals:
1. Reads pending proposals from JSON files
2. Applies approved improvements
3. Auto-commits changes to git
4. Logs results

Location: .ai/scripts/self-improvement-approve.py
Usage: python3 .ai/scripts/self-improvement-approve.py [--auto-approve]
"""

import json
import os
import sys
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Optional


class SelfImprovementApprover:
    def __init__(self):
        # Get repo root
        self.repo_root = Path(__file__).parent.parent.parent
        self.claude_dir = self.repo_root / ".claude"
        self.ai_dir = self.repo_root / ".ai"
        self.log_file = self.claude_dir / "self-improvement-log.md"

    def find_pending_proposals(self) -> list:
        """Find all pending improvement proposals"""
        proposals = []
        if not self.claude_dir.exists():
            return proposals

        for proposal_file in sorted(self.claude_dir.glob("pending-improvement-*.json")):
            try:
                with open(proposal_file) as f:
                    proposals.append({
                        "file": proposal_file,
                        "data": json.load(f)
                    })
            except (json.JSONDecodeError, IOError) as e:
                print(f"‚ö†Ô∏è  Error reading {proposal_file}: {e}")

        return proposals

    def apply_improvement(self, improvement: dict, proposal_id: str) -> bool:
        """Apply a single improvement"""
        try:
            improvement_type = improvement.get("type")
            target = improvement.get("target")
            action = improvement.get("action")

            if not target:
                return False

            target_path = self.repo_root / target
            target_path.parent.mkdir(parents=True, exist_ok=True)

            # Generate improvement content
            content = self._generate_improvement_content(improvement_type, action, proposal_id)

            if target_path.exists():
                # Append to existing file
                with open(target_path, "a") as f:
                    f.write("\n\n" + content)
                print(f"‚úÖ Appended to: {target}")
            else:
                # Create new file with header
                header = f"# {action}\n\n"
                header += f"_Auto-generated by Self-Improvement Engine_\n"
                header += f"_Proposal: {proposal_id}_\n\n"
                with open(target_path, "w") as f:
                    f.write(header + "\n" + content)
                print(f"‚úÖ Created: {target}")

            return True

        except Exception as e:
            print(f"‚ùå Failed to apply improvement: {e}")
            return False

    def _generate_improvement_content(self, improvement_type: str, action: str, proposal_id: str) -> str:
        """Generate content for the improvement"""
        timestamp = datetime.now().isoformat()

        if improvement_type == "knowledge_update":
            return f"""### {action}

**Proposal**: {proposal_id}
**Added**: {timestamp}

This section was auto-generated by the Self-Improvement Engine when a knowledge gap was detected.

**Content**: _Add your knowledge here_
- Key points
- Best practices
- Examples
- Related topics

---
"""

        elif improvement_type == "agent_update":
            return f"""## Enhanced Instructions

**Updated**: {timestamp}
**Proposal**: {proposal_id}

This section was auto-generated when the agent's instructions needed clarification.

**Improvements**:
- Clarified step / instruction
- Added example or edge case
- Better explanation

---
"""

        elif improvement_type == "guardrail_update":
            return f"""## New Rule / Enhancement

**Updated**: {timestamp}
**Proposal**: {proposal_id}

This guardrail was enhanced based on detected needs.

**Rule**:
- **When**: [circumstances]
- **Then**: [action/constraint]
- **Why**: [reasoning]

---
"""

        else:
            return f"## {action}\n\nAdded on {timestamp}\nProposal: {proposal_id}\n\n---\n"

    def auto_commit(self, improvements: list, proposal_id: str) -> bool:
        """Commit improvements to git"""
        try:
            os.chdir(self.repo_root)

            # Check if there are actual changes
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if not result.stdout.strip():
                print("‚ÑπÔ∏è  No changes to commit")
                return True

            # Stage changes
            subprocess.run(
                ["git", "add", "-A"],
                check=True,
                capture_output=True,
                timeout=10
            )

            # Create commit message
            commit_message = f"""Self-Improve: Learning from session {proposal_id}

Added {len(improvements)} improvement(s) based on detected knowledge gaps.

Improvements Made:
"""
            for improvement in improvements:
                commit_message += f"- {improvement.get('action', 'Unknown')}\n"

            commit_message += f"""
This commit was auto-generated by the Cloaked PM Self-Improvement Engine.
It represents knowledge the system learned and documented to prevent future gaps.

Timestamp: {datetime.now().isoformat()}
Proposal ID: {proposal_id}
"""

            # Commit
            result = subprocess.run(
                ["git", "commit", "-m", commit_message],
                check=True,
                capture_output=True,
                text=True,
                timeout=10
            )

            print(f"‚úÖ Committed to git")
            print(f"   Message: Self-Improve: Learning from session {proposal_id}")
            return True

        except subprocess.CalledProcessError as e:
            print(f"‚ö†Ô∏è  Git commit failed: {e.stderr}")
            return False
        except subprocess.TimeoutExpired:
            print(f"‚ö†Ô∏è  Git command timed out")
            return False
        except Exception as e:
            print(f"‚ùå Auto-commit failed: {e}")
            return False

    def process_proposal(self, proposal: dict, approve: bool = True) -> bool:
        """Process a single proposal"""
        session_id = proposal["data"]["session_id"]
        improvements = proposal["data"]["proposed_improvements"]

        print(f"\n{'='*80}")
        print(f"üìã Processing Proposal: {session_id}")
        print(f"{'='*80}")
        print(f"Improvements to apply: {len(improvements)}")

        if not approve:
            print("‚è≠Ô∏è  Skipped (not approved)")
            return False

        applied_improvements = []

        for improvement in improvements:
            if self.apply_improvement(improvement, session_id):
                applied_improvements.append(improvement)

        if applied_improvements:
            if self.auto_commit(applied_improvements, session_id):
                # Mark as completed in log
                self._log_completion(session_id, applied_improvements)

                # Clean up processed proposal file
                try:
                    proposal["file"].unlink()
                    print(f"‚úÖ Cleaned up proposal file")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Couldn't clean up proposal file: {e}")

                return True

        return False

    def _log_completion(self, session_id: str, improvements: list):
        """Log that improvements were applied"""
        if not self.log_file.exists():
            return

        completion_entry = f"""
## Completion: Proposal {session_id}

**Status**: Applied and committed
**Timestamp**: {datetime.now().isoformat()}
**Improvements Applied**: {len(improvements)}

‚úÖ All improvements have been applied and committed to git.

---
"""

        with open(self.log_file, "a") as f:
            f.write(completion_entry)

    def process_all_pending(self, auto_approve: bool = False):
        """Process all pending proposals"""
        proposals = self.find_pending_proposals()

        if not proposals:
            print("‚úÖ No pending improvements to process")
            return

        print(f"\n{'='*80}")
        print(f"üîî Found {len(proposals)} pending improvement proposal(s)")
        print(f"{'='*80}\n")

        for proposal in proposals:
            session_id = proposal["data"]["session_id"]

            if auto_approve:
                print(f"üöÄ Auto-approving: {session_id}")
                self.process_proposal(proposal, approve=True)
            else:
                print(f"‚ùì Review required: {session_id}")
                improvements = proposal["data"]["proposed_improvements"]
                print(f"   Improvements: {len(improvements)}")
                for i, imp in enumerate(improvements, 1):
                    print(f"     {i}. {imp['action']} ‚Üí {imp['target']}")
                print(f"   Proposal file: {proposal['file']}")
                print(f"\n   To approve this: python3 .ai/scripts/self-improvement-approve.py --auto-approve")
                print()

        print(f"\n{'='*80}")
        print(f"Done! Check .claude/self-improvement-log.md for details")
        print(f"{'='*80}\n")


def main():
    """CLI interface"""
    auto_approve = "--auto-approve" in sys.argv

    approver = SelfImprovementApprover()
    approver.process_all_pending(auto_approve=auto_approve)


if __name__ == "__main__":
    main()
