// PM AI Starter Kit - setup-shell-env.cjs
#!/usr/bin/env node

/**
 * Shell Environment Setup for MCP Credentials
 *
 * Creates/updates ~/.pm-ai-env.sh with exports needed by MCP servers
 * and other shell-level integrations. Consolidates credentials from
 * multiple sources into a single, properly formatted shell script.
 *
 * Usage:
 *   node scripts/setup-shell-env.cjs           # Interactive setup
 *   node scripts/setup-shell-env.cjs --check   # Check current state
 *   node scripts/setup-shell-env.cjs --fix     # Auto-fix zshrc sourcing
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const readline = require('readline');

const SHELL_ENV_PATH = path.join(os.homedir(), '.pm-ai-env.sh');
const ZSHRC_PATH = path.join(os.homedir(), '.zshrc');
const DOTENV_PATH = path.join(__dirname, '.env');

// MCP-required env vars (referenced by .claude/mcp.json)
const MCP_VARS = {
  POSTHOG_API_KEY: {
    description: 'PostHog analytics API key',
    docs: 'https://posthog.com/docs/api',
    pattern: /^phx?_/,
  },
  GITHUB_PERSONAL_ACCESS_TOKEN: {
    description: 'GitHub personal access token',
    docs: 'https://github.com/settings/tokens',
    pattern: /^gh[ps]_/,
  },
  FIGMA_PERSONAL_ACCESS_TOKEN: {
    description: 'Figma personal access token',
    docs: 'https://www.figma.com/developers/api#access-tokens',
    pattern: /^figd_/,
  },
  DD_API_KEY: {
    description: 'Datadog API key',
    docs: 'https://app.datadoghq.com/organization-settings/api-keys',
    pattern: /^[a-f0-9]{32}$/,
  },
  DD_APP_KEY: {
    description: 'Datadog application key',
    docs: 'https://app.datadoghq.com/organization-settings/application-keys',
    pattern: /^[a-f0-9]{40}$/,
  },
};

/**
 * Parse existing ~/.pm-ai-env.sh
 */
function parseShellEnv() {
  if (!fs.existsSync(SHELL_ENV_PATH)) {
    return {};
  }
  const content = fs.readFileSync(SHELL_ENV_PATH, 'utf8');
  const vars = {};
  for (const line of content.split('\n')) {
    const match = line.match(/^export\s+([A-Z_]+)=["']?(.*?)["']?\s*$/);
    if (match) {
      vars[match[1]] = match[2];
    }
  }
  return vars;
}

/**
 * Parse .env file (dotenv format)
 */
function parseDotenv() {
  if (!fs.existsSync(DOTENV_PATH)) {
    return {};
  }
  const content = fs.readFileSync(DOTENV_PATH, 'utf8');
  const vars = {};
  for (const line of content.split('\n')) {
    if (!line.trim() || line.startsWith('#')) continue;
    const clean = line.replace(/\r$/, '');
    const match = clean.match(/^([^=]+)=(.*)$/);
    if (match) {
      const val = match[2].trim().replace(/^["']|["']$/g, '');
      if (val) vars[match[1].trim()] = val;
    }
  }
  return vars;
}

/**
 * Scan zshrc for hardcoded exports that should be in ~/.pm-ai-env.sh
 */
function scanZshrc() {
  if (!fs.existsSync(ZSHRC_PATH)) {
    return { exports: {}, sourcesDotenv: false, sourcesShellEnv: false, content: '' };
  }
  const content = fs.readFileSync(ZSHRC_PATH, 'utf8');
  const exports = {};

  for (const line of content.split('\n')) {
    for (const varName of Object.keys(MCP_VARS)) {
      const match = line.match(new RegExp(`^export\\s+${varName}=["']?(.*?)["']?\\s*$`));
      if (match) {
        exports[varName] = match[1];
      }
    }
  }

  const sourcesDotenv = content.includes('scripts/.env');
  const sourcesShellEnv = content.includes('.pm-ai-env.sh');

  return { exports, sourcesDotenv, sourcesShellEnv, content };
}

/**
 * Generate ~/.pm-ai-env.sh content
 */
function generateShellEnv(vars) {
  const lines = [
    '#!/bin/bash',
    '# PM AI System - Shell Environment Variables',
    '# Auto-generated by setup-shell-env.cjs',
    '#',
    '# This file is sourced by ~/.zshrc to provide environment variables',
    '# needed by MCP servers and other shell-level integrations.',
    '#',
    '# Node.js scripts use scripts/.env via dotenv instead.',
    '# Do NOT put Google OAuth or other Node-only keys here.',
    '#',
    `# Last updated: ${new Date().toISOString()}`,
    '',
  ];

  for (const [key, meta] of Object.entries(MCP_VARS)) {
    const value = vars[key] || '';
    lines.push(`# ${meta.description}`);
    if (value) {
      // Escape shell metacharacters to prevent injection when sourced
      const escaped = value
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\$/g, '\\$')
        .replace(/`/g, '\\`');
      lines.push(`export ${key}="${escaped}"`);
    } else {
      lines.push(`# export ${key}=""  # Get from: ${meta.docs}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Check current state and report issues
 */
function checkState() {
  const shellEnvVars = parseShellEnv();
  const dotenvVars = parseDotenv();
  const zshrc = scanZshrc();

  const issues = [];
  const info = [];

  // Check if ~/.pm-ai-env.sh exists
  if (!fs.existsSync(SHELL_ENV_PATH)) {
    issues.push({
      severity: 'error',
      message: '~/.pm-ai-env.sh does not exist',
      fix: 'Run: node scripts/setup-shell-env.cjs',
    });
  } else {
    info.push(`~/.pm-ai-env.sh exists with ${Object.keys(shellEnvVars).length} var(s)`);
  }

  // Check if zshrc sources .env (bad)
  if (zshrc.sourcesDotenv) {
    issues.push({
      severity: 'warning',
      message: '~/.zshrc sources scripts/.env (should source ~/.pm-ai-env.sh instead)',
      fix: 'Run: node scripts/setup-shell-env.cjs --fix',
    });
  }

  // Check if zshrc sources ~/.pm-ai-env.sh (good)
  if (!zshrc.sourcesShellEnv) {
    issues.push({
      severity: 'error',
      message: '~/.zshrc does not source ~/.pm-ai-env.sh',
      fix: 'Run: node scripts/setup-shell-env.cjs --fix',
    });
  } else {
    info.push('~/.zshrc sources ~/.pm-ai-env.sh');
  }

  // Check for hardcoded exports in zshrc
  if (Object.keys(zshrc.exports).length > 0) {
    issues.push({
      severity: 'warning',
      message: `~/.zshrc has hardcoded exports: ${Object.keys(zshrc.exports).join(', ')}`,
      fix: 'Move to ~/.pm-ai-env.sh and remove from ~/.zshrc',
    });
  }

  // Check each MCP var
  for (const [key, meta] of Object.entries(MCP_VARS)) {
    const inShellEnv = shellEnvVars[key];
    const inZshrc = zshrc.exports[key];
    const inProcessEnv = process.env[key];

    if (!inShellEnv && !inZshrc && !inProcessEnv) {
      issues.push({
        severity: 'warning',
        message: `${key} not set anywhere - ${meta.description} MCP will fail`,
        fix: `Add to ~/.pm-ai-env.sh or get from ${meta.docs}`,
      });
    } else if (inShellEnv) {
      info.push(`${key}: set in ~/.pm-ai-env.sh`);
    } else if (inZshrc) {
      info.push(`${key}: set in ~/.zshrc (should move to ~/.pm-ai-env.sh)`);
    } else if (inProcessEnv) {
      info.push(`${key}: set in environment (source unknown)`);
    }
  }

  // Check .env for CRLF
  if (fs.existsSync(DOTENV_PATH)) {
    const content = fs.readFileSync(DOTENV_PATH, 'utf8');
    if (content.includes('\r')) {
      issues.push({
        severity: 'error',
        message: 'scripts/.env has Windows line endings (CRLF)',
        fix: "Run: perl -pi -e 's/\\r\\n/\\n/g' scripts/.env",
      });
    }
  }

  return { issues, info };
}

/**
 * Display check results
 */
function displayCheck() {
  const { issues, info } = checkState();

  console.log('\n  Shell Environment Check\n');

  if (info.length > 0) {
    for (const i of info) {
      console.log(`  OK  ${i}`);
    }
  }

  if (issues.length > 0) {
    console.log('');
    for (const issue of issues) {
      const icon = issue.severity === 'error' ? 'ERR' : 'WARN';
      console.log(`  ${icon}  ${issue.message}`);
      console.log(`        Fix: ${issue.fix}`);
    }
  }

  console.log('');

  const errors = issues.filter(i => i.severity === 'error');
  if (errors.length === 0) {
    console.log('  All checks passed.\n');
    return 0;
  } else {
    console.log(`  ${errors.length} issue(s) need attention.\n`);
    return 1;
  }
}

/**
 * Collect vars from all sources and write ~/.pm-ai-env.sh
 */
function createShellEnv() {
  const shellEnvVars = parseShellEnv();
  const dotenvVars = parseDotenv();
  const zshrc = scanZshrc();

  // Merge: existing shell env > zshrc exports > dotenv > process.env
  const merged = {};
  for (const key of Object.keys(MCP_VARS)) {
    merged[key] = shellEnvVars[key]
      || zshrc.exports[key]
      || dotenvVars[key]
      || process.env[key]
      || '';
  }

  const content = generateShellEnv(merged);
  fs.writeFileSync(SHELL_ENV_PATH, content, { mode: 0o600 });
  console.log(`  Wrote ${SHELL_ENV_PATH}`);

  // Report what was found
  for (const [key, val] of Object.entries(merged)) {
    if (val) {
      const masked = val.length > 12
        ? val.substring(0, 6) + '...' + val.substring(val.length - 4)
        : '***';
      console.log(`  SET  ${key} = ${masked}`);
    } else {
      console.log(`  MISS ${key} - not found in any source`);
    }
  }

  return merged;
}

/**
 * Fix zshrc: remove .env source, add .pm-ai-env.sh source, remove hardcoded exports
 */
function fixZshrc() {
  if (!fs.existsSync(ZSHRC_PATH)) {
    console.log('  No ~/.zshrc found, skipping.');
    return;
  }

  let content = fs.readFileSync(ZSHRC_PATH, 'utf8');
  let changes = 0;

  // Remove the .env sourcing block
  const envSourcePattern = /# ={3,}\n# PM AI System.*?\nif \[ -f.*scripts\/\.env.*?\n\s*set -a\n\s*source.*scripts\/\.env.*?\n\s*set \+a\nfi\n/s;
  if (envSourcePattern.test(content)) {
    content = content.replace(envSourcePattern, '');
    changes++;
    console.log('  Removed .env sourcing block from ~/.zshrc');
  }

  // Remove the comment about .env
  content = content.replace(/# Note: All API keys now sourced from.*\.env\n/g, '');

  // Remove hardcoded exports for MCP vars
  for (const key of Object.keys(MCP_VARS)) {
    const patternStr = `^export ${key}=["']?[^"'\\n]*["']?\\n`;
    const before = content;
    content = content.replace(new RegExp(patternStr, 'gm'), '');
    if (content !== before) {
      changes++;
      console.log(`  Removed hardcoded export ${key} from ~/.zshrc`);
    }
  }

  // Remove Datadog comment if exports were removed
  content = content.replace(/# Datadog MCP credentials\n(?=\n)/g, '');

  // Add ~/.pm-ai-env.sh sourcing if not present
  if (!content.includes('.pm-ai-env.sh')) {
    // Add after the first PATH export, or append to end if not found
    const pathIdx = content.indexOf('export PATH');
    const insertPoint = pathIdx >= 0
      ? content.indexOf('\n', pathIdx) + 1
      : content.length;
    const sourceBlock = `
# PM AI System - MCP and shell credentials
# Managed by: node scripts/setup-shell-env.cjs
if [ -f "$HOME/.pm-ai-env.sh" ]; then
  source "$HOME/.pm-ai-env.sh"
fi
`;
    content = content.slice(0, insertPoint) + sourceBlock + content.slice(insertPoint);
    changes++;
    console.log('  Added ~/.pm-ai-env.sh sourcing to ~/.zshrc');
  }

  if (changes > 0) {
    // Backup first
    const backupPath = ZSHRC_PATH + '.backup-' + Date.now();
    fs.copyFileSync(ZSHRC_PATH, backupPath);
    console.log(`  Backed up to ${backupPath}`);

    fs.writeFileSync(ZSHRC_PATH, content);
    console.log(`  Updated ~/.zshrc (${changes} change(s))`);
  } else {
    console.log('  ~/.zshrc already configured correctly');
  }
}

// CLI
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.includes('--check')) {
    process.exit(displayCheck());
  } else if (args.includes('--fix')) {
    console.log('\n  Fixing shell environment...\n');
    createShellEnv();
    console.log('');
    fixZshrc();
    console.log('\n  Done. Open a new terminal to pick up changes.\n');
  } else {
    // Interactive: create shell env, then offer to fix zshrc
    console.log('\n  Setting up shell environment for MCP...\n');
    createShellEnv();
    console.log('');

    const zshrc = scanZshrc();
    if (zshrc.sourcesDotenv || !zshrc.sourcesShellEnv || Object.keys(zshrc.exports).length > 0) {
      const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
      rl.question('  Update ~/.zshrc to source ~/.pm-ai-env.sh? [Y/n] ', (answer) => {
        if (!answer || answer.toLowerCase().startsWith('y')) {
          fixZshrc();
        } else {
          console.log('  Skipped. You can run with --fix later.');
        }
        rl.close();
        console.log('');
      });
    } else {
      console.log('  ~/.zshrc already configured correctly.\n');
    }
  }
}

module.exports = { checkState, MCP_VARS, SHELL_ENV_PATH };
